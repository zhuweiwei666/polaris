services:
  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_USER: polaris
      POSTGRES_PASSWORD: polaris_secret
      POSTGRES_DB: polaris
    volumes:
      - pgdata:/var/lib/postgresql/data
    restart: unless-stopped
    networks: [appnet]

  redis:
    image: redis:7-alpine
    volumes:
      - redisdata:/data
    restart: unless-stopped
    networks: [appnet]

  api:
    build:
      context: ../../
      dockerfile: apps/api/Dockerfile
    environment:
      NODE_ENV: production
      PORT: "8080"
      DATABASE_URL: postgresql://polaris:polaris_secret@postgres:5432/polaris?schema=public
      REDIS_URL: redis://redis:6379
      # Fallback env keys (DB config takes priority)
      OPENROUTER_API_KEY: ${OPENROUTER_API_KEY-}
      A2E_API_KEY: ${A2E_API_KEY-}
      GCS_BUCKET: ${GCS_BUCKET-}
    depends_on: [postgres, redis]
    restart: unless-stopped
    networks: [appnet]

  web:
    build:
      context: ../../
      dockerfile: apps/web/Dockerfile
      args:
        # Browser uses same-origin /api (served by nginx) to reach api.
        NEXT_PUBLIC_API_BASE_URL: "/api"
    environment:
      NODE_ENV: production
      PORT: "8080"
      # Server-side (SSR) fetch uses docker network to reach api.
      API_INTERNAL_BASE_URL: "http://api:8080/api"
      NEXT_PUBLIC_API_BASE_URL: "/api"
    restart: unless-stopped
    depends_on: [api]
    networks: [appnet]

  nginx:
    image: nginx:1.27-alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/conf.d/default.conf:ro
      - ./tls:/etc/nginx/tls:ro
    depends_on: [web, api]
    restart: unless-stopped
    networks: [appnet]

networks:
  appnet:
    driver: bridge

